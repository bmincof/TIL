# **TDD 이전의 개발 방식**

1. 만들 기능에 대해 설계를 고민 :
   어떤 클래스와 인터페이스를 도출할지 고민, 각 타입에 어떤 메서드를 넣을지 시간을 들여서 생각하기

2. 과정 1을 수행하면서 구현에 대해서도 고민:
   어떻게 구현할지 머릿속에 그려지면 코드를 쓰기 시작

3. 기능에 대한 구현을 완료한 것 같으면 기능을 테스트:
   원하는 대로 동작하지 않거나 문제가 발생하면 과정 2에서 작성한 코드를 디버깅하기

--> 한 번에 작성한 코드가 많으면 디버깅 시간도 길어짐

나 역시 Pulsar 프로젝트를 진행하면서 겪었던 문제들이다. 기능이 추가되면서 점점 디버깅하기 힘들어지고, 코드를 수정할 때마다 기능이 제대로 작동하는지 하나하나 확인해야 했다. 충분히 검사했다고 생각했음에도 발견하지 못한 버그들이 많이 있었다.

# **TDD란?**

TDD (Test-Driven-Development)는 기능을 검증하는 테스트 코드를 먼저 작성하고, 그 다음에 테스트를 통과시키기 위해 구현 코드를 작성한다.

# **JUnit5**

JUnit은 @Test 애노테이션을 붙인 메서드를 테스트 메서드로 인식한다.

_테스트 메서드_ : 기능을 검증하는 코드를 담고 있는 메서드

# **TDD의 진행 과정**

1. 기능을 검증하는 **테스트 코드를 먼저 작성**한다. (이 과정에서 테스트 대상이 될 클래스 이름, 메서드 이름, 파라미터 수, 리턴 타입, static 여부 등을 고민했다.)
2. 테스트 코드를 작성한 뒤 **컴파일 오류를 없애는데 필요한 클래스와 메서드를 작성**했다.
3. 테스트를 실행한 후 **테스트에 실패**했다.
4. **테스트를 통과할 만큼만 코드를 단순하게 구현**했다.
5. 실패한 **테스트를 통과시킨 뒤 새로운 테스트를 추가**해서 이전의 과정을 반복했다.

--> 테스트를 먼저 작성하고 테스트에 실패하면 테스트를 통과시킬 만큼 코드를 추가하는 과정을 반복하면서 점진적으로 기능을 완성해 나간다.

## **주의점**

1. 첫 번째 테스트를 잘 선택하는 것이 중요하다.
   ```
   그렇지 않으면 이후 진행이 순탄하게 흘러가지 않는다.
   가장 쉽거나 예외적인 상황부터 선택하자
   ```
2. 테스트 코드도 유지보수 대상이다.
   ```
   테스트 메서드에서 발생하는 중복을 알맞게 제거하거나 의미가 잘 드러나게 코드를 수정할 필요가 있다.
   단, 중복을 제거한 뒤에도 가독성이 떨어지지 않고 수정이 용이한 경우에만 중복을 제거해야 한다.
   ```

# **TDD 흐름**

1. 기능을 검증하는 테스트를 먼저 작성
2. 테스트를 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성
3. 테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링
4. 리팩토링을 수행한 뒤에는 다시 테스트를 실행해서 기존 기능이 망가지지 않았는지 확인

-> 위 과정을 반복하면서 점진적으로 기능을 완성해 나간다.

-> 위 과정을 레드(Red)-그린(Green)-리팩터(Refactor)라고 부르기도 한다.

# **TDD의 특징**

1. 테스트가 개발을 주도한다.

   테스트를 작성하는 과정에서 구현을 생각하지 않고 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만든다.

   테스트 코드를 만들면 다음 개발 범위가 정해지고, 테스트 코드가 추가되면서 검증하는 범위가 넓어질수록 구현도 점점 완성되어간다.

2. 지속적인 코드 정리

   구현을 완료한 뒤 리팩토링할 대상이 눈에 들어오면 리팩토링을 진행해서 코드를 정리했다. (테스트 코드 자체도 라팩토링 대상에 넣었다.)

   개발 과정에서 지속적으로 코드 정리를 하므로 코드 품질이 급격하게 나빠지지 않게 막아주며 향후 유지보수 비용을 낮추는데 기여한다.

3. 빠른 피드백

   코드 수정에 대한 피드백이 빠르다. 새로운 코드를 추가하거나 기존 코들르 수정하면 해당 코드가 올바른지 바로 확인할 수 있다.
